As a college student who’s interested in expanding his breadth of knowledge into software engineering and more generally across the “STEM” fields, I am quite appreciative of math as a conceptual foundation for most of the engineering that shapes our modern society. But what is the foundation of math? Why do I consider it meaningful to group certain concepts into that broader term? To start, I need a good framework of what math is all about. Math deals with numerals, shapes, and amounts (incl. constants and variables). There are tools in math with which amounts can be manipulated– they’re arithmetic operators. In order to manipulate a shape, I can express it as a collection of positions, and I can express each position as a set of independent amounts. In order to express an amount, I use numerals. Theoretically though, there are multiple ways in which I can express amounts. I could use tally marks, for example. Why are we using numerals then? Well, here’s the thing– math is a language, or more specifically, math relies on a shared protocol. We agree to use the same numeral symbols to represent the same amounts, the same grammar to express equations in, and the same coordinate system to plot positions in. Now, those agreements must be founded on some motivation, so my next question is as follows: what is math trying to accomplish? Well, math is generally expressed in two ways: it is expressed in symbolic linear sequences and it is expressed in nonlinear graphical pictures. In the latter method, the objective is typically to express a shape, position, or distance in a way that matches a human’s intuitive visual framework of daily life; in the former, the objective is typically to unambiguously specify complex properties (and to save some effort of drawing out everything). Math is certainly very abstract– it is a shared system of describing an arbitrary object’s existence, amount of existence, change of its properties, how it’s different from another object, and what happens when it influences another object (or is influenced by that object). I believe that abstraction is at the core of what makes math useful– it talks about objects in general terms, so that specific applications of these general terms share the same language of expression. Having this in mind, I will now create my own system of mathematical expression in this blogpost as a fun little exploration (of course, wanting to pass my math classes is also a motivating factor).

I have not yet written out the process of deriving my system, but I have practically already arrived at one that is sufficiently convincing for now. Below is the summary of what I have in mind for that system.

&lt;<b>synth</b>esis&gt; &lt;<b>p</b>resynth-<b>(n</b>on<b>)s</b>ensable&gt; &lt;<b>s</b>ynth-<b>c</b>hoice> &lt;<b>p</b>ost-<b>sc</b> <b>s</b>ynth&gt;
&lt;{...}: [synth-carrier is: …]&gt; &lt;[|...]: [ps(n)s may be: …]&gt; &lt;<b>p</b>scs-<b>c</b>omparative pscs-<b>r</b>ecurrence <b>s</b>ense&gt;
&lt;<b>a</b>uto<b>n</b>eo<b>s</b>ynth<b>choice</b>: an entity’s choice that defines that entity’s new-form self-resynthesis&gt;
entity1ansc <b>responsive to</b> entity2ansc ∴ entity1ansc {entity2ansc}
∴ entity1anscpcrs <b>same as</b> specific-neosynth of entity2anscpcrs
∴ entityset1anscpcrs integrated within anscpcrs-neosynth-pcrs → entityset2anscpcrs.
&lt;<b>a</b>nsc-(<b>u</b>n)<b>a</b>vailable <b>o</b>bject&gt; &lt;<b>c</b>o-contingency <b>auao</b>&gt; &lt;<b>n</b>on-<b>c</b>rossing <b>a</b>nsc-<b>a</b>vailability-<b>s</b>et<b>#</b>&gt;
&lt;<b>sep</b>aration-<b>p</b>crs&gt; &lt;<b>a</b>ao<b>#</b>-cauao <b>sepp</b>&gt;
aao {auao}. aao-cauao separation-pcrs [|{aao1-auao1 sepp, aao2-auao1 sepp}].
a1sepp attached to a2sepp → extension-synth a3sepp in same aas
⇒ a2sepp detached from a3sepp in same aas → a1sepp.
duplication of ncaas1-a1sepp across ncaas2 → extension-synth ncaas2sepp {ncaas1, ncaas2}.
